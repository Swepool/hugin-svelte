diff --git a/node_modules/hyperswarm/index.js b/node_modules/hyperswarm/index.js
index ad0de06..354a05d 100644
--- a/node_modules/hyperswarm/index.js
+++ b/node_modules/hyperswarm/index.js
@@ -18,7 +18,7 @@ const ERR_DESTROYED = 'Swarm has been destroyed'
 const ERR_DUPLICATE = 'Duplicate connection'
 
 module.exports = class Hyperswarm extends EventEmitter {
-  constructor (opts = {}) {
+  constructor (opts, sig, priv, keychain = {}) {
     super()
     const {
       seed,
@@ -30,15 +30,15 @@ module.exports = class Hyperswarm extends EventEmitter {
       firewall = allowAll
     } = opts
     this.keyPair = keyPair
-
+    this.priv = priv
     this.dht = opts.dht || new DHT({
       bootstrap: opts.bootstrap,
       debug: opts.debug
-    })
+    }, sig, priv, keychain)
     this.server = this.dht.createServer({
       firewall: this._handleFirewall.bind(this)
     }, this._handleServerConnection.bind(this))
-
+    this.keychain = keychain
     this.destroyed = false
     this.maxPeers = maxPeers
     this.maxClientConnections = maxClientConnections
@@ -49,7 +49,7 @@ module.exports = class Hyperswarm extends EventEmitter {
     this.peers = new Map()
     this.explicitPeers = new Set()
     this.listening = null
-
+    this.checkedSigs = []
     this._discovery = new Map()
     this._timer = new RetryTimer(this._requeue.bind(this), {
       backoffs: opts.backoffs,
@@ -65,7 +65,7 @@ module.exports = class Hyperswarm extends EventEmitter {
     this._clientConnections = 0
     this._serverConnections = 0
     this._firewall = firewall
-
+    this.sig = sig
     this.dht.on('network-change', this._handleNetworkChange.bind(this))
   }
 
@@ -139,6 +139,7 @@ module.exports = class Hyperswarm extends EventEmitter {
 
     // TODO: Support async firewalling at some point.
     if (this._handleFirewall(peerInfo.publicKey, null)) {
+      console.log("This firewall bann")
       peerInfo.ban(true)
       this._flushMaybe(peerInfo)
       return
@@ -212,10 +213,44 @@ module.exports = class Hyperswarm extends EventEmitter {
 
     const peerInfo = this.peers.get(b4a.toString(remotePublicKey, 'hex'))
     if (peerInfo && peerInfo.banned) return true
-
+    if (payload !== null) {
+    if (!payload.mpub) return true
+    if (!payload.mid) return true
+    //This id is already in use
+    if (this.checkedSigs.some(a => a === payload.mid)) return true
+    if (!this.checkTime(payload.mid)) return true
+
+    this.checkedSigs.push(payload.mid)
+      if (!this.checkKey(payload.mpub, payload.mid, this.priv))  {
+          console.log("Check failed")
+          return true
+      }
+    }
     return this._firewall(remotePublicKey, payload)
   }
 
+  checkTime = (date) => {
+    const day = 1000 * 60 * 60 * 24;
+    const dayAgo = Date.now() - day;
+    return date > dayAgo;
+  
+  }
+  //Add this check here aswell because firewall payload is null on connect. //TODO, Maybe i can fix that?
+  checkKey(pub, sig, keys) {
+      const sub = this.getSubKey(keys, sig)
+      if (sub.publicKey.toString('hex') === pub.toString('hex')) {
+        return true
+      } else {
+        return false
+      }
+    }
+  
+  getSubKey(keys, tweak) {
+      const random_buf = Buffer.alloc(32).fill(tweak)
+      const sub = keys.sub(random_buf).get()
+      return sub
+  }
+
   _handleServerConnectionSwap (existing, conn) {
     let closed = false
 
